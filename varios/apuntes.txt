funcion lambda 
palabra reservada lambda, parametros pueden ser mas de uno y por omision y valores de retorno
<nombre>=lambda <parametros de llegada> : <return>
raiz = lambda a,b:a**(1/b)
donde a es el numero que quiero calcular la raiz y b es el indice 
valor por omision 
raiz = lambda a,b=2:a**(1/b) de la misma forma que con funciones normales

------------------------------------------------------------------------------------------------------------------------------------

metodos nuevos para listas:

extend; sintaxis: lista1.extend(lista2) 

isnert; inserta un elemento en una posicion especifica de la lista. sintaxis: lista.insert(<posicion>,<dato>)

remove; elimina el primer elemento que encuentre con un valor especificado. lista.remove(<elemento)  

pop; elimina elemento por posicion especificada (indice). sintaxis; lista.pop(elemento); elemento = lista.pop(elemento) lo borras y lo guardas. si no le pasas nada borra el ultimo

in;te dice si esta el elemento (true or false(en una lista)) 

index; devuelve la posicion donde se encuentra el elemento, busca por contenido y devuelve pos. sintaxis; lista.index(elemento)

count; devuelve el numero de veces que aparece un elemento en la lista; cuenta = lista.count(elemento) 

sort; ordena la lista de forma ascendente. lista.sort(). lista.sort(reverse=True) -> descendente
-> para no perder consistencia entre listas paralelas
-> paquete = list(zip(lista_1, lista_2, lista_3)) 
-> paquete.sort(key=lambda x: x[i]) 

reverse; invierte la lista. sintaxis; lista.reverse()

copy; copias la lista asi como te digo chango; lista2= lista1.copy(). genera listas independientes

variable = sorted lista, key=lambda x: x[1]

zip; empaquetar listas en una tupla

----------------------------------------------------------------------------------------------------------------------------------------

CORTES O REBANADAS DE LISTAS 

operador nuevo = ":" 
[start:stop:step], el valor por omision de step es 1 
el stop es el anterior, osea, si el slice es de [2:7]
va a empezar desde 2 -> 6 
el slicing me da una nueva lista por resultado 
el paso suma posiciones 
el valor por omision de inicio es 0
el valor por omision de fin es el len de la lista
el corte es uno antes del valor de stop 
*como hago para invertir una lista por la tecnica de rebanado 
*[::-1]

----------------------------------------------------------------------------------------------------------------------------------------------

MODIFICAR VALORES DE LISTA -> CON REBANADAS

L[1:4] = [1,2,3] -> modifica los valores de la lista entre las posiciones, si te pasas de valores alarga la lista 
[1:1] abre un hueco en la lista, no reemplaza nada
[1:2] reemplaza la posicion de 1  
L2 = L1[:] COPIAS TODA LA LISTA 

------------------------------------------------------- -------------------------------------------------------------------------------------

LISTAS POR COMPRENSION 

L = [X**2 for X in range (5)]
l = [elemento (lista, variable, operacion) for i in range(x)]
l = [elemento for elemento in lista if elemento >= 0] --> FILTRO 
condicional dentro de la lista puede contener tanto if como else 


----------------------------------------------------------------------------------------------------
segunda parte de la materia 

-> instruccion break, continue 
-> clausula else 
-> while true 
-> intruccion pass

formas de romper un bucle (while o for) -> continue, break 

continue: rompe la iteracion en curso, no rompe el ciclo, pasa a la siguiente iteracion, 
sirve tanto para for como para while.

IMPORTANTE -> si tengo que romper un ciclo for deberia haber usado un ciclo while

break: finaliza el ciclo completo 

//////////////////////////////////////////////////////////

FOR - WHILE - ELSE -> PUEDEN TENER ASOCIADO UN ELSE, TODO LO QUE ESTE EN EL ELSE SE VA A EJECUTAR SI EL CICLO SE FINALIZA DE MANERA NORMAL 

ES DECIR, EL ELSE SE VA A EJECUTAR SI EL CICLO TERMINA DE FORMA NATURAL 

SI EL BUCLE SE ROMPE CON UN BREAK NO SE EJECUTA 

TE AHORRAS UN TREMENDO CHOCLO USANDO EL ELSE 

CON EL CONTINUE HAY QUE PROBAR 

/////////////////////////////////////////////////////////////////

while true, ciclo infinito a menos que exista una condicion que rompa el bucle 

BUENA PRACTICA: NO FUERCES HACER COSAS QUE NO TIENEN SENTIDO 


//////////////////////////////////////////////////////////////////

try: bloque protegido, dentro de este bloque van las instrucciones con potenciales errores 

las excepciones en python estan agrupadas por jerarquia 

hay excepciones genericas 

excepciones comunes:
IndexError
NameError
ValueError
ZeroDivisionError
SyntaxError
IdentationError
TypeError
AtributeError

otras: 
AssertionError
IdentationError
KeyError
KeyboardInterrupt
MemoryError
ModuleNotFoundError
RecursionError

Se ejecuta primero el bloque protegido.
Si se produce algún error durante la ejecución del 
mismo, se pasa automáticamente al bloque except que 
corresponda a la excepción generada.
Si no se produce ningún error, el bloque except es 
ignorado.
El bloque try-except puede tener tantos except como 
sea necesario, sin repetir ningún tipo de excepción.

el except puede no estar seguido de un tipo de excepcion, en cuyo caso capturara cualquier excepcion generada

es posible capturar el mensaje de error asociado a la excepcion con la instruccion as 


TRY EXCEPT ELSE 

se puede poner un else despues del except, solo se va a ejecutar si no se lanzo la excepcion

FINALLY se pone al final para ejecutar codigo sin importar si sale o no la excepcion

-----------------

raise: fuerza la ejecucion de una interrupcion 

esta instruccion RAISE tambien puede utilizarse para relanzar la ultima excepcion producida 

intruccion assert: evalua una condicion, si da verdadero, no levanta ninguna excepcion, si da false levanta una excepcion del tipo AssertionError
alternativa al if para hacer una comparacion que termine con un true or false
